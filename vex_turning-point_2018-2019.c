#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  Intake_Limit,   sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LeftDrive,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           Intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Flywheel,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Flywheel_2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Lift,          tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port8,           Flipper,       tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RightDrive,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Flipper is on a Y, the one with the encoder on it is +, the other one is -, prob should go to PowExp
// still need to do flywheel, and lift
/* Second stage of Intake will probably be Y'ed to the intake now,
and changed to a task to store the ball, ready to shoot*/
task Ball_Intake()
{
	//while(SensorValue[Intake_Limit] == 0) motor(Intake) = 127;
	//if(SensorValue[Intake_Limit] == 1) motor(Intake) = 0;
	int N = 0;
	if(vexRT[Btn8R] == 1)
	{
	  N = N + 1;
		waitUntil(vexRT[Btn8R] == 0);
	}
	int K = pow(-1,N);
	if(K == 1) motor(Intake) = 127;

}
/*task Lift_P0()
{
while(SensorValue[I2C_4] > 10) motor(Lift) = -127;
motor(Lift) = 0;
}
task Lift_P1()
{
int P1 = 120; // needs to be tested for actual value
while(SensorValue[I2C_4] > P1 + 10) motor(Lift) = -127;
while(SensorValue[I2C_4] < P1 - 10) motor(Lift) = 127;
if(P1 + 10 > SensorValue[I2C_4] > P1 - 10) motor(Lift) = 20;
}
task Lift_P2()
{
int P2 = 240; // needs to be tested for actual value
while(SensorValue[I2C_4] > P2 + 10) motor(Lift) = -127;
while(SensorValue[I2C_4] < P2 - 10) motor(Lift) = 127;
if(P2 + 10 > SensorValue[I2C_4] > P2 - 10) motor(Lift) = 20;
}*/
/*task Flip()
{
	while(SensorValue[I2C_1] < 260) motor(Flipper) = 55;

	if(260 < SensorValue[I2C_1] < 270)
	{
		motor(Flipper) = 20;
		//startTask(Lift_P0); // for testing, switch out with "wait1Msec(1000);"
		wait1Msec(1000);
		motor(Flipper) = 0;
	}
	else motor(Flipper) = 0;
}*/
task Launch()
{

	while(vexRT[Btn8D] == 0)
	{
		motor(Flywheel) = 90;
		motor(Flywheel_2) = 90;
	}
}
task main()
{
	resetMotorEncoder(Flipper);
	resetMotorEncoder(Lift);
	while(true)
	{
		int A;
		int B;

		if(abs(vexRT[Ch3]) > 20)	A = vexRT[Ch3];

		else A = 0;

		if(abs(vexRT[Ch4]) > 20) B = vexRT[Ch4];

		else B = 0;

		motor(RightDrive) = A-B;
		motor(LeftDrive) = A+B;

		if(vexRT[Btn8R] == 1) startTask(Ball_Intake);

		//if(vexRT[Btn5U] == 1) startTask(Flip);

		//if(vexRT[Btn5D] == 1) startTask(Lift_P0);

		//if(vexRT[Btn6D] == 1) startTask(Lift_P1);

		//if(vexRT[Btn6U] == 1) startTask(Lift_P2);

		if(vexRT[Btn7U] == 1) motor(Lift) = 127; //for now until im not too lazy to deal with the
		if(vexRT[Btn7D] == 1) motor(Lift) = -127;//integrated encoders.
		if(vexRT[Btn7U] == vexRT[Btn7D]) motor(Lift) = 0;

		else motor(Lift) = 0;

		if(vexRT[Btn8U] == 1) startTask(Launch);

		if(vexRT[Btn8D] == 1)
		{
			motor(Flywheel) = 0;
			motor(Flywheel_2) = 0;
		}
		if(vexRT[Btn5U] == 1) motor(Flipper) = 127;
		if(vexRT[Btn5D] == 1) motor(Flipper) = -127;
		if(vexRT[Btn5D] == vexRT[Btn5U]) motor(Flipper) = 0;

	}
}
